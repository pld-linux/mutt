diff -Nur mutt-1.3.27.orig/Makefile.am mutt-1.3.27/Makefile.am
--- mutt-1.3.27.orig/Makefile.am	Fri Nov  9 01:18:28 2001
+++ mutt-1.3.27/Makefile.am	Fri Feb  1 22:51:32 2002
@@ -18,7 +18,8 @@
 bin_PROGRAMS = mutt @DOTLOCK_TARGET@ @PGPAUX_TARGET@
 mutt_SOURCES = $(BUILT_SOURCES) \
 	addrbook.c alias.c attach.c base64.c browser.c buffy.c color.c \
-	commands.c complete.c compose.c copy.c curs_lib.c curs_main.c date.c \
+	commands.c complete.c compose.c compress.c copy.c curs_lib.c \
+	curs_main.c date.c \
 	edit.c enter.c flags.c init.c filter.c from.c getdomain.c \
 	handler.c hash.c hdrline.c headers.c help.c hook.c keymap.c \
 	main.c mbox.c menu.c mh.c mx.c pager.c parse.c pattern.c \
@@ -70,8 +71,8 @@
 	browser.h mbyte.h remailer.h url.h mutt_ssl_nss.c pgppacket.c 
 
 EXTRA_DIST = COPYRIGHT GPL OPS OPS.PGP TODO configure acconfig.h account.h \
-	attach.h buffy.h charset.h copy.h dotlock.h functions.h gen_defs \
-	globals.h hash.h history.h init.h keymap.h \
+	attach.h buffy.h charset.h compress.h copy.h dotlock.h functions.h \
+	gen_defs globals.h hash.h history.h init.h keymap.h \
 	mailbox.h mapping.h md5.h mime.h mutt.h mutt_curses.h mutt_menu.h \
 	mutt_regex.h mutt_sasl.h mutt_socket.h mutt_ssl.h mutt_tunnel.h \
 	mx.h pager.h pgp.h pop.h protos.h reldate.h rfc1524.h rfc2047.h \
diff -Nur mutt-1.3.27.orig/Muttrc.head mutt-1.3.27/Muttrc.head
--- mutt-1.3.27.orig/Muttrc.head	Tue Jan  1 21:18:02 2002
+++ mutt-1.3.27/Muttrc.head	Fri Feb  1 22:51:32 2002
@@ -19,6 +19,15 @@
 macro index   <f1> "!less /usr/local/doc/mutt/manual.txt\n" "Show Mutt documentation"
 macro pager   <f1> "!less /usr/local/doc/mutt/manual.txt\n" "Show Mutt documentation"
 
+# Use folders which match on \\.gz$ as gzipped folders:
+# open-hook \\.gz$ "gzip -cd %f > %t"
+# close-hook \\.gz$ "gzip -c %t > %f"
+# append-hook \\.gz$ "gzip -c %t >> %f"
+
+# open-hook \\.bz2$ "bzip2 -cd %f > %t"
+# close-hook \\.bz2$ "bzip2 -c %t > %f"
+# append-hook \\.bz2$ "bzip2 -c %t >> %f"
+
 # If Mutt is unable to determine your site's domain name correctly, you can
 # set the default here.
 #
diff -Nur mutt-1.3.27.orig/Muttrc.head.in mutt-1.3.27/Muttrc.head.in
--- mutt-1.3.27.orig/Muttrc.head.in	Mon Mar 20 11:25:49 2000
+++ mutt-1.3.27/Muttrc.head.in	Fri Feb  1 22:51:32 2002
@@ -19,6 +19,15 @@
 macro index   <f1> "!less @docdir@/manual.txt\n" "Show Mutt documentation"
 macro pager   <f1> "!less @docdir@/manual.txt\n" "Show Mutt documentation"
 
+# Use folders which match on \\.gz$ as gzipped folders:
+# open-hook \\.gz$ "gzip -cd %f > %t"
+# close-hook \\.gz$ "gzip -c %t > %f"
+# append-hook \\.gz$ "gzip -c %t >> %f"
+
+# open-hook \\.bz2$ "bzip2 -cd %f > %t"
+# close-hook \\.bz2$ "bzip2 -c %t > %f"
+# append-hook \\.bz2$ "bzip2 -c %t >> %f"
+
 # If Mutt is unable to determine your site's domain name correctly, you can
 # set the default here.
 #
diff -Nur mutt-1.3.27.orig/PATCHES mutt-1.3.27/PATCHES
--- mutt-1.3.27.orig/PATCHES	Mon Nov 26 20:16:22 2001
+++ mutt-1.3.27/PATCHES	Fri Feb  1 22:51:32 2002
@@ -0,0 +1 @@
+patch-1.3.27.rr.compressed.1
diff -Nur mutt-1.3.27.orig/compress.c mutt-1.3.27/compress.c
--- mutt-1.3.27.orig/compress.c	Thu Jan  1 01:00:00 1970
+++ mutt-1.3.27/compress.c	Fri Feb  1 22:51:32 2002
@@ -0,0 +1,483 @@
+/*
+ * Copyright (C) 1997 Alain Penders <Alain@Finale-Dev.com>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "mutt.h"
+
+#ifdef USE_COMPRESSED
+
+#include "mx.h"
+#include "mailbox.h"
+#include "mutt_curses.h"
+
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+
+typedef struct
+{
+  const char *close;	/* close-hook  command */
+  const char *open;	/* open-hook   command */
+  const char *append;	/* append-hook command */
+  off_t size;		/* size of real folder */
+} COMPRESS_INFO;
+
+
+/*
+ * ctx - context to lock
+ * excl - exclusive lock?
+ * retry - should retry if unable to lock?
+ */
+int mbox_lock_compressed (CONTEXT *ctx, FILE *fp, int excl, int retry)
+{
+  int r;
+
+  if ((r = mx_lock_file (ctx->realpath, fileno (fp), excl, 1, retry)) == 0)
+    ctx->locked = 1;
+  else if (retry && !excl)
+  {
+    ctx->readonly = 1;
+    return 0;
+  }
+
+  return (r);
+}
+
+void mbox_unlock_compressed (CONTEXT *ctx, FILE *fp)
+{
+  if (ctx->locked)
+  {
+    fflush (fp);
+
+    mx_unlock_file (ctx->realpath, fileno (fp), 1);
+    ctx->locked = 0;
+  }
+}
+
+static int is_new (const char *path)
+{
+  return (access (path, W_OK) != 0 && errno == ENOENT) ? 1 : 0;
+}
+
+static const char* find_compress_hook (int type, const char *path)
+{
+  const char* c = mutt_find_hook (type, path);
+  return (!c || !*c) ? NULL : c;
+}
+
+int mutt_can_read_compressed (const char *path)
+{
+  return find_compress_hook (M_OPENHOOK, path) ? 1 : 0;
+}
+
+/*
+ * if the file is new, we really do not append, but create, and so use
+ * close-hook, and not append-hook
+ */
+static const char* get_append_command (const char *path, const CONTEXT* ctx)
+{
+  COMPRESS_INFO *ci = (COMPRESS_INFO *) ctx->compressinfo;
+  return (is_new (path)) ? ci->close : ci->append;
+}
+
+int mutt_can_append_compressed (const char *path)
+{
+  int magic;
+
+  if (is_new (path))
+    return (find_compress_hook (M_CLOSEHOOK, path) ? 1 : 0);
+
+  magic = mx_get_magic (path);
+
+  if (magic != 0 && magic != M_COMPRESSED)
+    return 0;
+
+  return (find_compress_hook (M_APPENDHOOK, path)
+	  || (find_compress_hook (M_OPENHOOK, path)
+	      && find_compress_hook (M_CLOSEHOOK, path))) ? 1 : 0;
+}
+
+/* open a compressed mailbox */
+static COMPRESS_INFO *set_compress_info (CONTEXT *ctx)
+{
+  COMPRESS_INFO *ci;
+
+  /* Now lets uncompress this thing */
+  ci = safe_malloc (sizeof (COMPRESS_INFO));
+  ctx->compressinfo = (void*) ci;
+  ci->append = find_compress_hook (M_APPENDHOOK, ctx->path);
+  ci->open = find_compress_hook (M_OPENHOOK, ctx->path);
+  ci->close = find_compress_hook (M_CLOSEHOOK, ctx->path);
+  return ci;
+}
+
+static void set_path (CONTEXT* ctx)
+{
+  char tmppath[_POSIX_PATH_MAX];
+
+  /* Setup the right paths */
+  ctx->realpath = ctx->path;
+
+  /* Uncompress to /tmp */
+  mutt_mktemp (tmppath);
+  ctx->path = safe_malloc (strlen (tmppath) + 1);
+  strcpy (ctx->path, tmppath);
+}
+
+static int get_size (const char* path)
+{
+  struct stat sb;
+  if (stat (path, &sb) != 0)
+    return 0;
+  return (sb.st_size);
+}
+
+static void store_size (CONTEXT* ctx)
+{
+  COMPRESS_INFO *ci = (COMPRESS_INFO *) ctx->compressinfo;
+  ci->size = get_size (ctx->realpath);
+}
+
+static const char *
+compresshook_format_str (char *dest, size_t destlen, char op, const char *src,
+			 const char *fmt, const char *ifstring,
+			 const char *elsestring, unsigned long data,
+			 format_flag flags)
+{
+  char tmp[SHORT_STRING];
+
+  CONTEXT *ctx = (CONTEXT *) data;
+  switch (op)
+  {
+  case 'f':
+    snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+    snprintf (dest, destlen, tmp, ctx->realpath);
+    break;
+  case 't':
+    snprintf (tmp, sizeof (tmp), "%%%ss", fmt);
+    snprintf (dest, destlen, tmp, ctx->path);
+    break;
+  }
+  return (src);
+}
+
+/*
+ * check that the command has both %f and %t
+ * 0 means OK, -1 means error
+ */
+int mutt_test_compress_command (const char* cmd)
+{
+  return (strstr (cmd, "%f") && strstr (cmd, "%t")) ? 0 : -1;
+}
+
+static char *get_compression_cmd (const char* cmd, const CONTEXT* ctx)
+{
+  char expanded[_POSIX_PATH_MAX];
+  mutt_FormatString (expanded, sizeof (expanded), cmd, compresshook_format_str,
+		     (unsigned long) ctx, 0);
+  return safe_strdup (expanded);
+}
+
+int mutt_check_mailbox_compressed (CONTEXT* ctx)
+{
+  COMPRESS_INFO *ci = (COMPRESS_INFO *) ctx->compressinfo;
+  if (ci->size != get_size (ctx->realpath))
+  {
+    safe_free ((void**)&ctx->compressinfo);
+    safe_free ((void**)&ctx->realpath);
+    mutt_error _("Mailbox was corrupted!");
+    return (-1);
+  }
+  return (0);
+}
+
+int mutt_open_read_compressed (CONTEXT *ctx)
+{
+  char *cmd;
+  FILE *fp;
+  int rc;
+
+  COMPRESS_INFO *ci = set_compress_info (ctx);
+  if (!ci->open) {
+    ctx->magic = 0;
+    safe_free ((void**)ctx->compressinfo);
+    return (-1);
+  }
+  if (!ci->close || access (ctx->path, W_OK) != 0)
+    ctx->readonly = 1;
+
+  set_path (ctx);
+  store_size (ctx);
+
+  if (!ctx->quiet)
+    mutt_message (_("Decompressing %s..."), ctx->realpath);
+
+  cmd = get_compression_cmd (ci->open, ctx);
+  if (cmd == NULL)
+    return (-1);
+  dprint (2, (debugfile, "DecompressCmd: '%s'\n", cmd));
+
+  if ((fp = fopen (ctx->realpath, "r")) == NULL)
+  {
+    mutt_perror (ctx->realpath);
+    safe_free ((void **)&cmd);
+    return (-1);
+  }
+  mutt_block_signals ();
+  if (mbox_lock_compressed (ctx, fp, 0, 1) == -1)
+  {
+    fclose (fp);
+    mutt_unblock_signals ();
+    mutt_error _("Unable to lock mailbox!");
+    safe_free ((void **)&cmd);
+    return (-1);
+  }
+
+  endwin ();
+  fflush (stdout);
+  fprintf (stderr, _("Decompressing %s...\n"),ctx->realpath);
+  rc = mutt_system (cmd);
+  mbox_unlock_compressed (ctx, fp);
+  mutt_unblock_signals ();
+  fclose (fp);
+
+  if (rc)
+  {
+    mutt_any_key_to_continue (NULL);
+    ctx->magic = 0;
+    safe_free ((void**)ctx->compressinfo);
+    mutt_error (_("Error executing: %s : unable to open the mailbox!\n"), cmd);
+  }
+  safe_free ((void **)&cmd);
+  if (rc)
+    return (-1);
+
+  if (mutt_check_mailbox_compressed (ctx))
+    return (-1);
+
+  ctx->magic = mx_get_magic (ctx->path);
+
+  return (0);
+}
+
+void restore_path (CONTEXT* ctx)
+{
+  safe_free ((void **)&ctx->path);
+  ctx->path = ctx->realpath;
+}
+
+/* remove the temporary mailbox */
+void remove_file (CONTEXT* ctx)
+{
+  if (ctx->magic == M_MBOX || ctx->magic == M_MMDF)
+    remove (ctx->path);
+}
+
+int mutt_open_append_compressed (CONTEXT *ctx)
+{
+  FILE *fh;
+  COMPRESS_INFO *ci = set_compress_info (ctx);
+
+  if (!get_append_command (ctx->path, ctx))
+  {
+    if (ci->open && ci->close)
+      return (mutt_open_read_compressed (ctx));
+
+    ctx->magic = 0;
+    safe_free ((void**)&ctx->compressinfo);
+    return (-1);
+  }
+
+  set_path (ctx);
+
+  ctx->magic = DefaultMagic;
+
+  if (!is_new (ctx->realpath))
+    if (ctx->magic == M_MBOX || ctx->magic == M_MMDF)
+      if ((fh = fopen (ctx->path, "w")))
+	fclose (fh);
+  /* No error checking - the parent function will catch it */
+
+  return (0);
+}
+
+/* close a compressed mailbox */
+void mutt_fast_close_compressed (CONTEXT *ctx)
+{
+  dprint (2, (debugfile, "mutt_fast_close_compressed called on '%s'\n",
+	      ctx->path));
+
+  if (ctx->compressinfo)
+  {
+    if (ctx->fp)
+      fclose (ctx->fp);
+    ctx->fp = NULL;
+    /* if the folder was removed, remove the gzipped folder too */
+    if ((ctx->magic > 0) 
+	&& (access (ctx->path, F_OK) != 0) 
+	&& ! option (OPTSAVEEMPTY))
+      remove (ctx->realpath);
+    else
+      remove_file (ctx);
+
+    restore_path (ctx);
+    safe_free ((void**)&ctx->compressinfo);
+  }
+}
+
+/* return 0 on success, -1 on failure */
+int mutt_sync_compressed (CONTEXT* ctx)
+{
+  char *cmd;
+  int rc = 0;
+  FILE *fp;
+  COMPRESS_INFO *ci = (COMPRESS_INFO *) ctx->compressinfo;
+
+  if (!ctx->quiet)
+    mutt_message (_("Compressing %s..."), ctx->realpath);
+
+  cmd = get_compression_cmd (ci->close, ctx);
+  if (cmd == NULL)
+    return (-1);
+
+  if ((fp = fopen (ctx->realpath, "a")) == NULL)
+  {
+    mutt_perror (ctx->realpath);
+    safe_free ((void **)&cmd);
+    return (-1);
+  }
+  mutt_block_signals ();
+  if (mbox_lock_compressed (ctx, fp, 1, 1) == -1)
+  {
+    fclose (fp);
+    mutt_unblock_signals ();
+    mutt_error _("Unable to lock mailbox!");
+    store_size (ctx);
+    safe_free ((void **)&cmd);
+    return (-1);
+  }
+
+  dprint (2, (debugfile, "CompressCommand: '%s'\n", cmd));
+
+  endwin ();
+  fflush (stdout);
+  fprintf (stderr, _("Compressing %s...\n"), ctx->realpath);
+  if (mutt_system (cmd))
+  {
+    mutt_any_key_to_continue (NULL);
+    mutt_error (_("%s: Error compressing mailbox! Original mailbox deleted, uncompressed one kept!\n"), ctx->path);
+    rc = -1;
+  }
+
+  mbox_unlock_compressed (ctx, fp);
+  mutt_unblock_signals ();
+  fclose (fp);
+
+  safe_free ((void **)&cmd);
+
+  store_size (ctx);
+
+  return (rc);
+}
+
+int mutt_slow_close_compressed (CONTEXT *ctx)
+{
+  FILE *fp;
+  const char *append;
+  char *cmd;
+  COMPRESS_INFO *ci = (COMPRESS_INFO *) ctx->compressinfo;
+
+  dprint (2, (debugfile, "mutt_slow_close_compressed called on '%s'\n",
+	      ctx->path));
+
+  if (! (ctx->append
+	 && ((append = get_append_command (ctx->realpath, ctx))
+	     || (append = ci->close))))
+  { 
+    /* if we can not or should not append, we only have to remove the */
+    /* compressed info, because sync was already called               */
+    mutt_fast_close_compressed (ctx);
+    return (0);
+  }
+
+  if (ctx->fp)
+    fclose (ctx->fp);
+  ctx->fp = NULL;
+
+  if (!ctx->quiet)
+  {
+    if (append == ci->close)
+      mutt_message (_("Compressing %s..."), ctx->realpath);
+    else
+      mutt_message (_("Compressed-appending to %s..."), ctx->realpath);
+  }
+
+  cmd = get_compression_cmd (append, ctx);
+  if (cmd == NULL)
+    return (-1);
+
+  if ((fp = fopen (ctx->realpath, "a")) == NULL)
+  {
+    mutt_perror (ctx->realpath);
+    safe_free ((void **)&cmd);
+    return (-1);
+  }
+  mutt_block_signals ();
+  if (mbox_lock_compressed (ctx, fp, 1, 1) == -1)
+  {
+    fclose (fp);
+    mutt_unblock_signals ();
+    mutt_error _("Unable to lock mailbox!");
+    safe_free ((void **)&cmd);
+    return (-1);
+  }
+
+  dprint (2, (debugfile, "CompressCmd: '%s'\n", cmd));
+
+  endwin ();
+  fflush (stdout);
+
+  if (append == ci->close)
+    fprintf (stderr, _("Compressing %s...\n"), ctx->realpath);
+  else
+    fprintf (stderr, _("Compressed-appending to %s...\n"), ctx->realpath);
+
+  if (mutt_system (cmd))
+  {
+    mutt_any_key_to_continue (NULL);
+    mutt_error (_(" %s: Error compressing mailbox!  Uncompressed one kept!\n"),
+		ctx->path);
+    safe_free ((void **)&cmd);
+    mbox_unlock_compressed (ctx, fp);
+    mutt_unblock_signals ();
+    fclose (fp);
+    return (-1);
+  }
+
+  mbox_unlock_compressed (ctx, fp);
+  mutt_unblock_signals ();
+  fclose (fp);
+  remove_file (ctx);
+  restore_path (ctx);
+  safe_free ((void **)&cmd);
+  safe_free ((void **)&ctx->compressinfo);
+
+  return (0);
+}
+
+#endif /* USE_COMPRESSED */
diff -Nur mutt-1.3.27.orig/compress.h mutt-1.3.27/compress.h
--- mutt-1.3.27.orig/compress.h	Thu Jan  1 01:00:00 1970
+++ mutt-1.3.27/compress.h	Fri Feb  1 22:51:32 2002
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 1997 Alain Penders <Alain@Finale-Dev.com>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+int mutt_can_read_compressed (const char *);
+int mutt_can_append_compressed (const char *);
+int mutt_open_read_compressed (CONTEXT *);
+int mutt_open_append_compressed (CONTEXT *);
+int mutt_slow_close_compressed (CONTEXT *);
+int mutt_sync_compressed (CONTEXT *);
+int mutt_test_compress_command (const char *);
+int mutt_check_mailbox_compressed (CONTEXT *);
+void mutt_fast_close_compressed (CONTEXT *);
diff -Nur mutt-1.3.27.orig/configure.in mutt-1.3.27/configure.in
--- mutt-1.3.27.orig/configure.in	Fri Feb  1 22:51:17 2002
+++ mutt-1.3.27/configure.in	Fri Feb  1 22:51:32 2002
@@ -644,6 +644,11 @@
                 AC_DEFINE(LOCALES_HACK,1,[ Define if the result of isprint() is unreliable. ])
         fi])
 
+AC_ARG_ENABLE(compressed, [  --enable-compressed        Enable compressed folders support ],
+	[if test x$enableval = xyes; then
+                AC_DEFINE(USE_COMPRESSED,1, [ Define to support compressed folders. ])
+        fi])
+
 AC_ARG_WITH(exec-shell, [  --with-exec-shell=SHELL    Specify alternate shell (ONLY if /bin/sh is broken)],
         [if test $withval != yes; then
                 AC_DEFINE_UNQUOTED(EXECSHELL, "$withval")
diff -Nur mutt-1.3.27.orig/curs_main.c mutt-1.3.27/curs_main.c
--- mutt-1.3.27.orig/curs_main.c	Wed Jan 23 00:42:01 2002
+++ mutt-1.3.27/curs_main.c	Fri Feb  1 22:51:32 2002
@@ -1010,6 +1010,11 @@
         {
 	  int check;
 
+#ifdef USE_COMPRESSED
+	  if (Context->compressinfo && Context->realpath)
+	    mutt_str_replace (&LastFolder, Context->realpath);
+	  else
+#endif
 	  mutt_str_replace (&LastFolder, Context->path);
 	  oldcount = Context ? Context->msgcount : 0;
 
diff -Nur mutt-1.3.27.orig/doc/manual.sgml mutt-1.3.27/doc/manual.sgml
--- mutt-1.3.27.orig/doc/manual.sgml	Tue Jan  1 21:18:05 2002
+++ mutt-1.3.27/doc/manual.sgml	Fri Feb  1 22:51:32 2002
@@ -2318,6 +2318,176 @@
 macro pager \cb |urlview\n
 </verb></tscreen>
 
+<sect1>Compressed folders Support (OPTIONAL)
+<p>
+
+If Mutt was compiled with compressed folders support (by running the
+<em/configure/ script with the <em/--enable-compressed/ flag), Mutt
+can open folders stored in an arbitrary format, provided that the user
+has a script to convert from/to this format to one of the accepted.
+
+The most common use is to open compressed archived folders e.g. with
+gzip.
+
+In addition, the user can provide a script that gets a folder in an
+accepted format and appends its context to the folder in the
+user-defined format, which may be faster than converting the entire
+folder to the accepted format, appending to it and converting back to
+the user-defined format.
+
+There are three hooks defined (<ref id="open-hook" name="open-hook">,
+<ref id="close-hook" name="close-hook"> and <ref id="append-hook"
+name="append-hook">) which define commands to uncompress and compress
+a folder and to append messages to an existing compressed folder 
+respectively.
+
+For example:
+
+<tscreen><verb>
+open-hook \\.gz$ "gzip -cd %f &gt; %t" 
+close-hook \\.gz$ "gzip -c %t &gt; %f"
+append-hook \\.gz$ "gzip -c %t &gt;&gt; %f" 
+</verb></tscreen>
+
+You do not have to specify all of the commands. If you omit <ref
+id="append-hook" name="append-hook">, the folder will be open and
+closed again each time you will add to it. If you omit <ref
+id="close-hook" name="close-hook"> (or give empty command) , the
+folder will be open in the  mode. If you specify <ref
+id="append-hook" name="append-hook"> though you'll be able to append
+to the folder.
+
+Note that Mutt will only try to use hooks if the file is not in one of
+the accepted formats. In particular, if the file is empty, mutt
+supposes it is not compressed. This is important because it allows the
+use of programs that do not have well defined extensions. Just use
+&dquot;.&dquot; as a regexp. But this may be surprising if your
+compressing script produces empty files. In this situation, unset <ref
+id="save_empty" name="&dollar;save&lowbar;empty">, so that the compressed file
+will be removed if you delete all of the messages.
+
+<sect2>Open a compressed mailbox for reading<label id="open-hook">
+<p>
+Usage: <tt/open-hook/ <em/regexp/ &dquot;<em/command/&dquot;
+
+The <em/command/ is the command that can be used for opening the
+folders whose names match <em/regexp/.
+
+The <em/command/ string is the printf-like format string, and it
+should accept two parameters: &percnt;f, which is replaced with the
+(compressed) folder name, and &percnt;t which is replaced with the
+name of the temporary folder to which to write.
+
+&percnt;f and &percnt;t can be repeated any number of times in the
+command string, and all of the entries are replaced with the
+appropriate folder name. In addition, &percnt;&percnt; is replaced by
+&percnt;, as in printf, and any other &percnt;anything is left as is.
+
+The <em/command/ should <bf/not/ remove the original compressed file.
+The <em/command/ should return non-zero exit status if it fails, so
+mutt knows something's wrong.
+
+Example:
+
+<tscreen><verb>
+open-hook \\.gz$ "gzip -cd %f &gt; %t" 
+</verb></tscreen>
+
+If the <em/command/ is empty, this operation is disabled for this file
+type.
+
+<sect2>Write a compressed mailbox<label id="close-hook">
+<p>
+Usage: <tt/close-hook/ <em/regexp/ &dquot;<em/command/&dquot;
+
+This is used to close the folder that was open with the <ref id="open-hook" 
+name="open-hook"> command after some changes were made to it.
+
+The <em/command/ string is the command that can be used for closing the
+folders whose names match <em/regexp/. It has the same format as in 
+the <ref id="open-hook" name="open-hook"> command. Temporary folder
+in this case is the folder previously produced by the <ref id="open-hook"
+name="open-hook"> command.
+
+The <em/command/ should <bf/not/ remove the decompressed file. The
+<em/command/ should return non-zero exit status if it fails, so mutt
+knows something's wrong.
+
+Example:
+
+<tscreen><verb>
+close-hook \\.gz$ "gzip -c %t &gt; %f"
+</verb></tscreen>
+
+If the <em/command/ is empty, this operation is disabled for this file
+type, and the file can only be open in the read-only mode.
+
+<ref id="close-hook" name ="close-hook"> is not called when you exit
+from the folder if the folder was not changed.
+
+<sect2>Append a message to a compressed mailbox<label id="append-hook">
+<p>
+Usage: <tt/append-hook/ <em/regexp/ &dquot;<em/command/&dquot;
+
+This command is used for saving to an existing compressed folder.
+The <em/command/ is the command that can be used for appending to the
+folders whose names match <em/regexp/. It has the same format as in 
+ the <ref id="open-hook" name="open-hook"> command.
+The temporary folder in this case contains the messages that are being
+appended. 
+
+The <em/command/ should <bf/not/ remove the decompressed file. The
+<em/command/ should return non-zero exit status if it fails, so mutt
+knows something's wrong.
+
+Example:
+
+<tscreen><verb>
+append-hook \\.gz$ "gzip -c %t &gt;&gt; %f" 
+</verb></tscreen>
+
+When <ref id="append-hook" name="append-hook"> is used, the folder is
+not opened, which saves time, but this means that we can not find out
+what the folder type is. Thus the default (<ref id="mbox_type"
+name="&dollar;mbox&lowbar;type">) type is always supposed (i.e.
+this is the format used for the temporary folder).
+
+If the file does not exist when you save to it, <ref id="close-hook"
+name="close-hook"> is called, and not <ref id="append-hook"
+name="append-hook">. <ref id="append-hook" name="append-hook"> is only
+for appending to existing folders.
+
+If the <em/command/ is empty, this operation is disabled for this file
+type. In this case, the folder will be open and closed again (using
+<ref id="open-hook" name="open-hook"> and <ref id="close-hook" 
+name="close-hook">respectively) each time you will add to it.
+
+<sect2>Encrypted folders
+<p>
+The compressed folders support can also be used to handle encrypted
+folders. If you want to encrypt a folder with PGP, you may want to use
+the following hooks:
+
+<tscreen><verb>
+open-hook  \\.pgp$ "pgp -f &lt; %f &gt; %t"
+close-hook \\.pgp$ "pgp -fe YourPgpUserIdOrKeyId &lt; %t &gt; %f"
+</verb></tscreen>
+
+Please note, that PGP does not support appending to an encrypted
+folder, so there is no append-hook defined.
+
+If you are using GnuPG instead of PGP, you may use the following hooks
+instead:
+
+<tscreen><verb>
+open-hook  \\.gpg$ "gpg --decrypt &lt; %f &gt; %t"
+close-hook \\.gpg$ "gpg --encrypt --recipient YourGpgUserIdOrKeyId &lt; %t &gt; %f"
+</verb></tscreen>
+
+<bf/Note:/ the folder is temporary stored decrypted in the /tmp
+directory, where it can be read by your system administrator. So think
+about the security aspects of this.
+
 <sect>Mutt's MIME Support
 <p>
 Quite a bit of effort has been made to make Mutt the premier text-mode
@@ -2868,12 +3038,16 @@
 <item>
 <tt><ref id="alternative_order" name="alternative&lowbar;order"></tt> <em/mimetype/ &lsqb; <em/mimetype/ ... &rsqb;
 <item>
+<tt><ref id="append-hook" name="append-hook"></tt> <em/regexp/ &dquot;<em/command/&dquot;
+<item>
 <tt><ref id="auto_view" name="auto&lowbar;view"></tt> <em/mimetype/ &lsqb; <em/mimetype/ ... &rsqb;
 <item>
 <tt><ref id="bind" name="bind"></tt> <em/map/ <em/key/ <em/function/
 <item>
 <tt><ref id="charset-hook" name="charset-hook"></tt> <em/alias/ <em/charset/
 <item>
+<tt><ref id="close-hook" name="close-hook"></tt> <em/regexp/ &dquot;<em/command/&dquot;
+<item>
 <tt><ref id="color" name="color"></tt> <em/object/ <em/foreground/ <em/background/ &lsqb; <em/regexp/ &rsqb;
 <item>
 <tt><ref id="color" name="uncolor"></tt> <em/index/ <em/pattern/ &lsqb; <em/pattern/ ... &rsqb;
@@ -2916,6 +3090,8 @@
 <item>
 <tt><ref id="my_hdr" name="unmy&lowbar;hdr"></tt> <em/field/ &lsqb; <em/field/ ... &rsqb;
 <item>
+<tt><ref id="open-hook" name="open-hook"></tt> <em/regexp/ &dquot;<em/command/&dquot;
+<item>
 <tt><ref id="pgp-hook" name="pgp-hook"></tt> <em/pattern/ <em/key-id/
 <item>
 <tt><ref id="push" name="push"></tt> <em/string/
diff -Nur mutt-1.3.27.orig/doc/manual.sgml.head mutt-1.3.27/doc/manual.sgml.head
--- mutt-1.3.27.orig/doc/manual.sgml.head	Wed Jan 23 00:42:01 2002
+++ mutt-1.3.27/doc/manual.sgml.head	Fri Feb  1 22:51:32 2002
@@ -2319,6 +2319,176 @@
 macro pager \cb |urlview\n
 </verb></tscreen>
 
+<sect1>Compressed folders Support (OPTIONAL)
+<p>
+
+If Mutt was compiled with compressed folders support (by running the
+<em/configure/ script with the <em/--enable-compressed/ flag), Mutt
+can open folders stored in an arbitrary format, provided that the user
+has a script to convert from/to this format to one of the accepted.
+
+The most common use is to open compressed archived folders e.g. with
+gzip.
+
+In addition, the user can provide a script that gets a folder in an
+accepted format and appends its context to the folder in the
+user-defined format, which may be faster than converting the entire
+folder to the accepted format, appending to it and converting back to
+the user-defined format.
+
+There are three hooks defined (<ref id="open-hook" name="open-hook">,
+<ref id="close-hook" name="close-hook"> and <ref id="append-hook"
+name="append-hook">) which define commands to uncompress and compress
+a folder and to append messages to an existing compressed folder 
+respectively.
+
+For example:
+
+<tscreen><verb>
+open-hook \\.gz$ "gzip -cd %f &gt; %t" 
+close-hook \\.gz$ "gzip -c %t &gt; %f"
+append-hook \\.gz$ "gzip -c %t &gt;&gt; %f" 
+</verb></tscreen>
+
+You do not have to specify all of the commands. If you omit <ref
+id="append-hook" name="append-hook">, the folder will be open and
+closed again each time you will add to it. If you omit <ref
+id="close-hook" name="close-hook"> (or give empty command) , the
+folder will be open in the  mode. If you specify <ref
+id="append-hook" name="append-hook"> though you'll be able to append
+to the folder.
+
+Note that Mutt will only try to use hooks if the file is not in one of
+the accepted formats. In particular, if the file is empty, mutt
+supposes it is not compressed. This is important because it allows the
+use of programs that do not have well defined extensions. Just use
+&dquot;.&dquot; as a regexp. But this may be surprising if your
+compressing script produces empty files. In this situation, unset <ref
+id="save_empty" name="&dollar;save&lowbar;empty">, so that the compressed file
+will be removed if you delete all of the messages.
+
+<sect2>Open a compressed mailbox for reading<label id="open-hook">
+<p>
+Usage: <tt/open-hook/ <em/regexp/ &dquot;<em/command/&dquot;
+
+The <em/command/ is the command that can be used for opening the
+folders whose names match <em/regexp/.
+
+The <em/command/ string is the printf-like format string, and it
+should accept two parameters: &percnt;f, which is replaced with the
+(compressed) folder name, and &percnt;t which is replaced with the
+name of the temporary folder to which to write.
+
+&percnt;f and &percnt;t can be repeated any number of times in the
+command string, and all of the entries are replaced with the
+appropriate folder name. In addition, &percnt;&percnt; is replaced by
+&percnt;, as in printf, and any other &percnt;anything is left as is.
+
+The <em/command/ should <bf/not/ remove the original compressed file.
+The <em/command/ should return non-zero exit status if it fails, so
+mutt knows something's wrong.
+
+Example:
+
+<tscreen><verb>
+open-hook \\.gz$ "gzip -cd %f &gt; %t" 
+</verb></tscreen>
+
+If the <em/command/ is empty, this operation is disabled for this file
+type.
+
+<sect2>Write a compressed mailbox<label id="close-hook">
+<p>
+Usage: <tt/close-hook/ <em/regexp/ &dquot;<em/command/&dquot;
+
+This is used to close the folder that was open with the <ref id="open-hook" 
+name="open-hook"> command after some changes were made to it.
+
+The <em/command/ string is the command that can be used for closing the
+folders whose names match <em/regexp/. It has the same format as in 
+the <ref id="open-hook" name="open-hook"> command. Temporary folder
+in this case is the folder previously produced by the <ref id="open-hook"
+name="open-hook"> command.
+
+The <em/command/ should <bf/not/ remove the decompressed file. The
+<em/command/ should return non-zero exit status if it fails, so mutt
+knows something's wrong.
+
+Example:
+
+<tscreen><verb>
+close-hook \\.gz$ "gzip -c %t &gt; %f"
+</verb></tscreen>
+
+If the <em/command/ is empty, this operation is disabled for this file
+type, and the file can only be open in the read-only mode.
+
+<ref id="close-hook" name ="close-hook"> is not called when you exit
+from the folder if the folder was not changed.
+
+<sect2>Append a message to a compressed mailbox<label id="append-hook">
+<p>
+Usage: <tt/append-hook/ <em/regexp/ &dquot;<em/command/&dquot;
+
+This command is used for saving to an existing compressed folder.
+The <em/command/ is the command that can be used for appending to the
+folders whose names match <em/regexp/. It has the same format as in 
+ the <ref id="open-hook" name="open-hook"> command.
+The temporary folder in this case contains the messages that are being
+appended. 
+
+The <em/command/ should <bf/not/ remove the decompressed file. The
+<em/command/ should return non-zero exit status if it fails, so mutt
+knows something's wrong.
+
+Example:
+
+<tscreen><verb>
+append-hook \\.gz$ "gzip -c %t &gt;&gt; %f" 
+</verb></tscreen>
+
+When <ref id="append-hook" name="append-hook"> is used, the folder is
+not opened, which saves time, but this means that we can not find out
+what the folder type is. Thus the default (<ref id="mbox_type"
+name="&dollar;mbox&lowbar;type">) type is always supposed (i.e.
+this is the format used for the temporary folder).
+
+If the file does not exist when you save to it, <ref id="close-hook"
+name="close-hook"> is called, and not <ref id="append-hook"
+name="append-hook">. <ref id="append-hook" name="append-hook"> is only
+for appending to existing folders.
+
+If the <em/command/ is empty, this operation is disabled for this file
+type. In this case, the folder will be open and closed again (using
+<ref id="open-hook" name="open-hook"> and <ref id="close-hook" 
+name="close-hook">respectively) each time you will add to it.
+
+<sect2>Encrypted folders
+<p>
+The compressed folders support can also be used to handle encrypted
+folders. If you want to encrypt a folder with PGP, you may want to use
+the following hooks:
+
+<tscreen><verb>
+open-hook  \\.pgp$ "pgp -f &lt; %f &gt; %t"
+close-hook \\.pgp$ "pgp -fe YourPgpUserIdOrKeyId &lt; %t &gt; %f"
+</verb></tscreen>
+
+Please note, that PGP does not support appending to an encrypted
+folder, so there is no append-hook defined.
+
+If you are using GnuPG instead of PGP, you may use the following hooks
+instead:
+
+<tscreen><verb>
+open-hook  \\.gpg$ "gpg --decrypt &lt; %f &gt; %t"
+close-hook \\.gpg$ "gpg --encrypt --recipient YourGpgUserIdOrKeyId &lt; %t &gt; %f"
+</verb></tscreen>
+
+<bf/Note:/ the folder is temporary stored decrypted in the /tmp
+directory, where it can be read by your system administrator. So think
+about the security aspects of this.
+
 <sect>Mutt's MIME Support
 <p>
 Quite a bit of effort has been made to make Mutt the premier text-mode
@@ -2869,12 +3039,16 @@
 <item>
 <tt><ref id="alternative_order" name="alternative&lowbar;order"></tt> <em/mimetype/ &lsqb; <em/mimetype/ ... &rsqb;
 <item>
+<tt><ref id="append-hook" name="append-hook"></tt> <em/regexp/ &dquot;<em/command/&dquot;
+<item>
 <tt><ref id="auto_view" name="auto&lowbar;view"></tt> <em/mimetype/ &lsqb; <em/mimetype/ ... &rsqb;
 <item>
 <tt><ref id="bind" name="bind"></tt> <em/map/ <em/key/ <em/function/
 <item>
 <tt><ref id="charset-hook" name="charset-hook"></tt> <em/alias/ <em/charset/
 <item>
+<tt><ref id="close-hook" name="close-hook"></tt> <em/regexp/ &dquot;<em/command/&dquot;
+<item>
 <tt><ref id="color" name="color"></tt> <em/object/ <em/foreground/ <em/background/ &lsqb; <em/regexp/ &rsqb;
 <item>
 <tt><ref id="color" name="uncolor"></tt> <em/index/ <em/pattern/ &lsqb; <em/pattern/ ... &rsqb;
@@ -2917,6 +3091,8 @@
 <item>
 <tt><ref id="my_hdr" name="unmy&lowbar;hdr"></tt> <em/field/ &lsqb; <em/field/ ... &rsqb;
 <item>
+<tt><ref id="open-hook" name="open-hook"></tt> <em/regexp/ &dquot;<em/command/&dquot;
+<item>
 <tt><ref id="pgp-hook" name="pgp-hook"></tt> <em/pattern/ <em/key-id/
 <item>
 <tt><ref id="push" name="push"></tt> <em/string/
diff -Nur mutt-1.3.27.orig/doc/muttrc.man mutt-1.3.27/doc/muttrc.man
--- mutt-1.3.27.orig/doc/muttrc.man	Fri Dec 28 18:14:28 2001
+++ mutt-1.3.27/doc/muttrc.man	Fri Feb  1 22:51:32 2002
@@ -258,6 +258,24 @@
 The pgp-hook command provides a method by which you can
 specify the ID of the public key to be used when encrypting messages
 to a certain recipient.
+.PP
+.nf
+\fBopen-hook\fP \fIregexp\fP "\fIcommand\fP"
+\fBclose-hook\fP \fIregexp\fP "\fIcommand\fP"
+\fBappend-hook\fP \fIregexp\fP "\fIcommand\fP"
+.fi
+.IP
+These commands provide a way to handle compressed folders. The given
+\fBregexp\fP specifies which folders are taken as compressed (e.g.
+"\fI\\\\.gz$\fP"). The commands tell Mutt how to uncompress a folder
+(\fBopen-hook\fP), compress a folder (\fBclose-hook\fP) or append a
+compressed mail to a compressed folder (\fBappend-hook\fP). The
+\fIcommand\fP string is the 
+.BR printf (3)
+like format string, and it should accept two parameters: \fB%f\fP,
+which is replaced with the (compressed) folder name, and \fB%t\fP
+which is replaced with the name of the temporary folder to which to
+write.
 .TP
 \fBpush\fP \fIstring\fP
 This command adds the named \fIstring\fP to the keyboard buffer.
diff -Nur mutt-1.3.27.orig/doc/muttrc.man.head mutt-1.3.27/doc/muttrc.man.head
--- mutt-1.3.27.orig/doc/muttrc.man.head	Wed Jan 23 00:42:01 2002
+++ mutt-1.3.27/doc/muttrc.man.head	Fri Feb  1 22:51:32 2002
@@ -258,6 +258,24 @@
 The pgp-hook command provides a method by which you can
 specify the ID of the public key to be used when encrypting messages
 to a certain recipient.
+.PP
+.nf
+\fBopen-hook\fP \fIregexp\fP "\fIcommand\fP"
+\fBclose-hook\fP \fIregexp\fP "\fIcommand\fP"
+\fBappend-hook\fP \fIregexp\fP "\fIcommand\fP"
+.fi
+.IP
+These commands provide a way to handle compressed folders. The given
+\fBregexp\fP specifies which folders are taken as compressed (e.g.
+"\fI\\\\.gz$\fP"). The commands tell Mutt how to uncompress a folder
+(\fBopen-hook\fP), compress a folder (\fBclose-hook\fP) or append a
+compressed mail to a compressed folder (\fBappend-hook\fP). The
+\fIcommand\fP string is the 
+.BR printf (3)
+like format string, and it should accept two parameters: \fB%f\fP,
+which is replaced with the (compressed) folder name, and \fB%t\fP
+which is replaced with the name of the temporary folder to which to
+write.
 .TP
 \fBpush\fP \fIstring\fP
 This command adds the named \fIstring\fP to the keyboard buffer.
diff -Nur mutt-1.3.27.orig/hook.c mutt-1.3.27/hook.c
--- mutt-1.3.27.orig/hook.c	Fri Jun 29 12:05:50 2001
+++ mutt-1.3.27/hook.c	Fri Feb  1 22:51:32 2002
@@ -19,6 +19,10 @@
 #include "mutt.h"
 #include "mailbox.h"
 
+#ifdef USE_COMPRESSED
+#include "compress.h"
+#endif
+
 #include <limits.h>
 #include <string.h>
 #include <stdlib.h>
@@ -87,6 +91,16 @@
     memset (&pattern, 0, sizeof (pattern));
     pattern.data = safe_strdup (path);
   }
+#ifdef USE_COMPRESSED
+  else if (data & (M_APPENDHOOK | M_OPENHOOK | M_CLOSEHOOK))
+  {
+    if (mutt_test_compress_command (command.data))
+    {
+      strfcpy (err->data, _("bad formatted command string"), err->dsize);
+      return (-1);
+    }
+  }
+#endif
   else if (DefaultHook && (data & (M_FOLDERHOOK | M_MBOXHOOK | M_SENDHOOK |
 				   M_FCCHOOK | M_SAVEHOOK | M_MESSAGEHOOK)))
   {
diff -Nur mutt-1.3.27.orig/init.h mutt-1.3.27/init.h
--- mutt-1.3.27.orig/init.h	Mon Dec 10 11:09:03 2001
+++ mutt-1.3.27/init.h	Fri Feb  1 22:51:32 2002
@@ -2447,6 +2447,11 @@
   { "fcc-hook",		mutt_parse_hook,	M_FCCHOOK },
   { "fcc-save-hook",	mutt_parse_hook,	M_FCCHOOK | M_SAVEHOOK },
   { "folder-hook",	mutt_parse_hook,	M_FOLDERHOOK },
+#ifdef USE_COMPRESSED
+  { "open-hook",	mutt_parse_hook,	M_OPENHOOK },
+  { "close-hook",	mutt_parse_hook,	M_CLOSEHOOK },
+  { "append-hook",	mutt_parse_hook,	M_APPENDHOOK },
+#endif
   { "hdr_order",	parse_list,		UL &HeaderOrderList },
   { "iconv-hook",	mutt_parse_hook,	M_ICONVHOOK }, 
   { "ignore",		parse_ignore,		0 },
diff -Nur mutt-1.3.27.orig/main.c mutt-1.3.27/main.c
--- mutt-1.3.27.orig/main.c	Wed Nov  7 11:40:26 2001
+++ mutt-1.3.27/main.c	Fri Feb  1 22:51:32 2002
@@ -328,6 +328,12 @@
 #else
 	"-LOCALES_HACK  "
 #endif
+
+#ifdef USE_COMPRESSED
+	"+COMPRESSED  "
+#else
+	"-COMPRESSED  "
+#endif
 	      
 #ifdef HAVE_WC_FUNCS
 	"+HAVE_WC_FUNCS  "
diff -Nur mutt-1.3.27.orig/mbox.c mutt-1.3.27/mbox.c
--- mutt-1.3.27.orig/mbox.c	Wed Oct 31 10:40:05 2001
+++ mutt-1.3.27/mbox.c	Fri Feb  1 22:51:32 2002
@@ -28,6 +28,10 @@
 #include "sort.h"
 #include "copy.h"
 
+#ifdef USE_COMPRESSED
+#include "compress.h"
+#endif
+
 #include <sys/stat.h>
 #include <dirent.h>
 #include <string.h>
@@ -1045,6 +1049,12 @@
 int mbox_close_mailbox (CONTEXT *ctx)
 {
   mx_unlock_file (ctx->path, fileno (ctx->fp), 1);
+
+#ifdef USE_COMPRESSED
+  if (ctx->compressinfo)
+    mutt_slow_close_compressed (ctx);
+#endif
+
   mutt_unblock_signals ();
   mx_fastclose_mailbox (ctx);
   return 0;
diff -Nur mutt-1.3.27.orig/mutt.h mutt-1.3.27/mutt.h
--- mutt-1.3.27.orig/mutt.h	Wed Jan 23 00:42:01 2002
+++ mutt-1.3.27/mutt.h	Fri Feb  1 22:51:32 2002
@@ -143,6 +143,11 @@
 #define M_PGPHOOK	(1<<8)
 #endif
 #define M_ACCOUNTHOOK	(1<<9)
+#ifdef USE_COMPRESSED
+#define M_OPENHOOK	(1<<10)
+#define M_APPENDHOOK	(1<<11)
+#define M_CLOSEHOOK	(1<<12)
+#endif
 
 /* tree characters for linearize_tree and print_enriched_string */
 #define M_TREE_LLCORNER		1
@@ -745,6 +750,11 @@
   void *data;			/* driver specific data */
 #endif /* USE_IMAP */
 
+#ifdef USE_COMPRESSED
+  void *compressinfo;		/* compressed mbox module private data */
+  char *realpath;		/* path to compressed mailbox */
+#endif /* USE_COMPRESSED */
+
   short magic;			/* mailbox type */
 
   unsigned int locked : 1;	/* is the mailbox locked? */
diff -Nur mutt-1.3.27.orig/mx.c mutt-1.3.27/mx.c
--- mutt-1.3.27.orig/mx.c	Wed Jan 23 00:42:01 2002
+++ mutt-1.3.27/mx.c	Fri Feb  1 22:51:32 2002
@@ -26,6 +26,10 @@
 #include "keymap.h"
 #include "url.h"
 
+#ifdef USE_COMPRESSED
+#include "compress.h"
+#endif
+
 #ifdef HAVE_PGP
 #include "pgp.h"
 #endif
@@ -448,6 +452,10 @@
     return (-1);
   }
 
+#ifdef USE_COMPRESSED
+  if (magic == 0 && mutt_can_read_compressed (path))
+    return M_COMPRESSED;
+#endif
   return (magic);
 }
 
@@ -489,6 +497,13 @@
 {
   struct stat sb;
 
+#ifdef USE_COMPRESSED
+  /* special case for appending to compressed folders -
+   * even if we can not open them for reading */
+  if (mutt_can_append_compressed (ctx->path))
+    mutt_open_append_compressed (ctx);
+#endif
+
   ctx->append = 1;
 
 #ifdef USE_IMAP
@@ -649,7 +664,12 @@
   }
 
   ctx->magic = mx_get_magic (path);
-  
+
+#ifdef USE_COMPRESSED
+  if (ctx->magic == M_COMPRESSED)
+    mutt_open_read_compressed (ctx);
+#endif
+
   if(ctx->magic == 0)
     mutt_error (_("%s is not a mailbox."), path);
 
@@ -755,6 +775,10 @@
     mutt_free_header (&ctx->hdrs[i]);
   safe_free ((void **) &ctx->hdrs);
   safe_free ((void **) &ctx->v2r);
+#ifdef USE_COMPRESSED
+  if (ctx->compressinfo)
+    mutt_fast_close_compressed (ctx);
+#endif
   safe_free ((void **) &ctx->path);
   safe_free ((void **) &ctx->pattern);
   if (ctx->limit_pattern) 
@@ -812,6 +836,12 @@
   if (tmp && tmp->new == 0)
     mutt_update_mailbox (tmp);
 #endif
+
+#ifdef USE_COMPRESSED
+  if (rc == 0 && ctx->compressinfo)
+    return mutt_sync_compressed (ctx);
+#endif
+
   return rc;
 }
 
@@ -1018,6 +1048,11 @@
       !mutt_is_spool(ctx->path) && !option (OPTSAVEEMPTY))
     mx_unlink_empty (ctx->path);
 
+#ifdef USE_COMPRESSED
+  if (ctx->compressinfo && mutt_slow_close_compressed (ctx))
+    return (-1);
+#endif
+
   mx_fastclose_mailbox (ctx);
 
   return 0;
@@ -1325,6 +1360,11 @@
 {
   int rc;
 
+#ifdef USE_COMPRESSED
+  if (ctx->compressinfo)
+    return mutt_check_mailbox_compressed (ctx);
+#endif
+
   if (ctx)
   {
     if (ctx->locked) lock = 0;
diff -Nur mutt-1.3.27.orig/mx.h mutt-1.3.27/mx.h
--- mutt-1.3.27.orig/mx.h	Wed Oct 31 10:40:05 2001
+++ mutt-1.3.27/mx.h	Fri Feb  1 22:51:32 2002
@@ -41,6 +41,9 @@
 #ifdef USE_POP
   , M_POP
 #endif
+#ifdef USE_COMPRESSED
+  , M_COMPRESSED
+#endif
 };
 
 WHERE short DefaultMagic INITVAL (M_MBOX);
diff -Nur mutt-1.3.27.orig/po/POTFILES.in mutt-1.3.27/po/POTFILES.in
--- mutt-1.3.27.orig/po/POTFILES.in	Tue Oct 10 21:18:37 2000
+++ mutt-1.3.27/po/POTFILES.in	Fri Feb  1 22:51:32 2002
@@ -8,6 +8,7 @@
 color.c
 commands.c
 compose.c
+compress.c
 curs_lib.c
 curs_main.c
 edit.c
diff -Nur mutt-1.3.27.orig/po/de.po mutt-1.3.27/po/de.po
--- mutt-1.3.27.orig/po/de.po	Wed Jan 23 00:43:05 2002
+++ mutt-1.3.27/po/de.po	Fri Feb  1 22:51:32 2002
@@ -654,6 +654,48 @@
 msgid "Message written."
 msgstr "Nachricht geschrieben."
 
+#: compress.c:203 mbox.c:661
+msgid "Mailbox was corrupted!"
+msgstr "Mailbox wurde zerstört!"
+
+#: compress.c:228 compress.c:253
+#, c-format
+msgid "Decompressing %s...\n"
+msgstr "Entpacke %s...\n"
+
+#: compress.c:246 compress.c:367 compress.c:443 mbox.c:706
+msgid "Unable to lock mailbox!"
+msgstr "Kann Mailbox nicht für exklusiven Zugriff sperren!"
+
+#: compress.c:264
+#, c-format
+msgid "Error executing: %s : unable to open the mailbox!\n"
+msgstr "Fehler beim Ausführen von %s : Kann die Mailbox nicht öffnen!\n"
+
+#: compress.c:350 compress.c:377 compress.c:423 compress.c:454
+#, c-format
+msgid "Compressing %s...\n"
+msgstr "Komprimiere %s...\n"
+
+#: compress.c:381
+#, c-format
+msgid ""
+"%s: Error compressing mailbox! Original mailbox deleted, uncompressed one "
+"kept!\n"
+msgstr ""
+"%s: Fehler beim Komprimieren der Mailbox! Ursprüngliche Mailbox gelöscht, "
+"entpackte gespeichert!\n"
+
+#: compress.c:425 compress.c:456
+#, c-format
+msgid "Compressed-appending to %s...\n"
+msgstr "Hänge komprimiert an %s... an\n"
+
+#: compress.c:461
+#, c-format
+msgid " %s: Error compressing mailbox!  Uncompressed one kept!\n"
+msgstr " %s: Fehler beim packen der Mailbox! Entpackte Mailbox gespeichert!\n"
+
 #: curs_lib.c:153
 msgid "yes"
 msgstr "ja"
@@ -1137,6 +1179,10 @@
 msgid "Help for %s"
 msgstr "Hilfe für %s"
 
+#: hook.c:96
+msgid "bad formatted command string"
+msgstr "Hook enthält nicht die Muster %f und %t"
+
 #: hook.c:240
 msgid "unhook: Can't do unhook * from within a hook."
 msgstr "unhook: Innerhalb eines hook kann kein unhook * aufgerufen werden."
@@ -2459,18 +2505,10 @@
 msgid "Mailbox is corrupt!"
 msgstr "Mailbox fehlerhaft!"
 
-#: mbox.c:665
-msgid "Mailbox was corrupted!"
-msgstr "Mailbox wurde zerstört!"
-
 #: mbox.c:702 mbox.c:978
 msgid "Fatal error!  Could not reopen mailbox!"
 msgstr "Fataler Fehler, konnte Mailbox nicht erneut öffnen!"
 
-#: mbox.c:711
-msgid "Unable to lock mailbox!"
-msgstr "Kann Mailbox nicht für exklusiven Zugriff sperren!"
-
 #. this means ctx->changed or ctx->deleted was set, but no
 #. * messages were found to be changed or deleted.  This should
 #. * never happen, is we presume it is a bug in mutt.
diff -Nur mutt-1.3.27.orig/status.c mutt-1.3.27/status.c
--- mutt-1.3.27.orig/status.c	Fri Mar  3 11:10:14 2000
+++ mutt-1.3.27/status.c	Fri Feb  1 22:51:32 2002
@@ -93,6 +93,14 @@
 
     case 'f':
       snprintf (fmt, sizeof(fmt), "%%%ss", prefix);
+#ifdef USE_COMPRESSED
+      if (Context && Context->compressinfo && Context->realpath)
+      {
+	 strfcpy (tmp, Context->realpath, sizeof (tmp));
+	 mutt_pretty_mailbox (tmp);
+      }
+      else
+#endif
       if (Context && Context->path)
       {
 	strfcpy (tmp, Context->path, sizeof (tmp));
